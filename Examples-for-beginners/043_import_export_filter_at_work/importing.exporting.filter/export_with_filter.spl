/*
This example shows how to use the SPL feature to apply a filter for what gets
exported and what gets imported. This powerful feature lets the downstream
import operators to specify what kind of tuples they want to receive by
specifying conditional expressions involving tuple attributes. That lets the
Streams runtime to apply content-based filtering at the point of export. Those who
need such a feature to control what information should be sent downstream based on
the tuple contents can make use of this flexible feature. This can be done on the
fly without stopping and restarting the application.

The main composite below exports a stream with filter option true.
In order to test this, always launch the export_with_filter first in distributed mode.
After that, launch the import_with_filter in distributed mode.
*/

namespace importing.exporting.filter;

composite export_with_filter {
	type
		SimpleTransaction = tuple<int64 number, rstring string>;
	
	graph
		// Create a Beacon signal every 10 seconds.
		stream<SimpleTransaction> SimpleTxStream = Beacon() {
			logic
				state: {
					mutable int64 _number_cnt = 0;
					mutable int64 _string_cnt = 0;
				}
				
			param
				iterations: 7000;
				period: 5.0;
				
			output
				SimpleTxStream: number = ++_number_cnt, string = "String" + (rstring)++_string_cnt;
		} // End of SimpleTxStream = Beacon()
		
		// Export the output stream generated by the Beacon.
		() as ExportedSimpleTxStream = Export(SimpleTxStream as STS) {
			param
				// Let us allow the downstream import operators filter this 
				// exported stream based on the tuple attribute values.
				allowFilter: true;
				properties: {exportedStreams = 1l};
		} // End of ExportedSimpleTxStream = Export(ModifiedSimpleTxStream)	
}
