<% # Switch to Perl scripting mode to get the config settings in ./config/config.cfg
#!/usr/bin/perl -w
###################################################################################################
use lib "scripts";
use Configuration;
my $config=new Configuration(".");
 
my $inputDir=$config->get('INPUT_DIR')->[0]; 
my $pattern=$config->get('PATTERN')->[0]; 
my $parallelLoaders=$config->get('PARALLEL_LOADERS')->[0]; 
 
# check the value of $parallelLoaders 
if ($parallelLoaders  eq  $parallelLoaders+0)  # is a number
{  
	if ($parallelLoaders > 10)
	{
		$parallelLoaders = 10;
	}
	  
	if ($parallelLoaders < 1)
	{
		$parallelLoaders = 1;
	} 
}
else
{
	$parallelLoaders = 2;
}
%>


/* Copyright (C) 2013-2014, International Business Machines Corporation  */
/* All Rights Reserved                                	                 */

namespace com.ibm.streamsx.db.dbloader;

/**
* The composite **OracleLoader** scans the input directory, passes the filenames to OracleLoadFile if connection check was successful.
* 
* Reads configuration parameter "PARALLEL_LOADERS" direct from config.cfg file. 
* 
* Depending to the value of "PARALLEL_LOADERS" (1 -10) creates n Gates and n Controls operators
* to start several parallel file loaders.
* 
* @input ConfigurationData (database name,  database user, database password)
* @output Result rstring result
*/
composite OracleLoader(output Result ; input ConfigurationData)
{	
	graph 
			 
		/**
		 * GetDbStatus
		 * Creates a database connection via sqlplus to check the user name and 
		 * the user password of database and the status of Oracle database.
		 */                  	
		stream<boolean connected> GetDbStatus = OracleCheckDb(ConfigurationData)
		{
		}
			
		/**
		 * CheckDbStatus
		 * Checks the Oracle database status.  
		 * It is a security check to prevent the database user account lock due wrong password. 
		 * Only a successfully connection to a running Oracle database can open the SwitchDirScan. 
		 */                  	
		stream<boolean dbReady> CheckDbStatus = Custom(GetDbStatus)
		{
			logic
			state : 
			{
				mutable rstring checkResult = "";
			}
	
			onTuple GetDbStatus:
			{
				if 	(connected)
				{
					submit({ dbReady =  true }, CheckDbStatus) ;
		
				}
			}
		}
		
		
		/**
		 * DirScan
		 * The DirectoryScan operator watches the input directory, and generates 
		 * the file names and a counter on the output.
		 */                  	
		stream<rstring fileName, int64 count> DirScan = DirectoryScan()
		{
			logic
			state :
				{
					mutable int64 counter = 1l ;
				}
			param
				directory : getSubmissionTimeValue("inputDir", "<%=$inputDir%>"); 
				initDelay : 5.0 ;
				pattern : "<%=$pattern%>" ;
			output DirScan: fileName = FullPath(), count = counter++; 
		}

		/**
		 * SwitchDirScan
		 * Switch to hold up Data tuples from ScanDir until CheckConnection operator is initialized. 
		 * Any CheckDbStatus tuple will cause the switch to open.
		 * initialStatus defaults to false (Switch is open/blocked).          
		 */                  	                            
		stream<DirScan> SwitchDirScan = Switch(DirScan ; CheckDbStatus)
		{
			param
				status : true ; // any CheckDbStatus tuple will cause the switch to open  
				initialStatus : false;         
		}
	
		/**
		 * AddFileName
		 * Add file name from scan directory to the configuration.
		 */
		stream<ConfigData configData> AddFileName = Custom(SwitchDirScan; ConfigurationData) 
		{                                       
			logic
			state :
				{
					mutable ConfigData cfgData;
				}
			
				onTuple ConfigurationData :
				{
					cfgData = configData;
				}	
		
				onTuple SwitchDirScan :
				{
					cfgData.fileName = fileName;
					cfgData.counter = count;
					submit({ configData =  cfgData }, AddFileName) ;
				}	
	
		}   
	 
		/**
		 * ThreadedSplit
		 * A ThreadedSplit operator is used to split a stream, and process 
		 * tuples in parallel.
		 * Split the stream into <%=$parallelLoaders%> streams and use a following Gate to ensure load balancing.
		 * 
		 */
		(<% my $cnt=0;  for ($cnt=1; $cnt<=$parallelLoaders; $cnt++) {%>
		stream<AddFileName> Split<%=$cnt%><% if ($cnt < $parallelLoaders) { %>;<% }} %>) = ThreadedSplit(AddFileName)
		{
			param
				bufferSize : 1u ;
			config
				placement : partitionColocation("Split"), // ensure same PE as the Gates 
				partitionExlocation("Process") ;
		}
		<% my $cnt=0;  for ($cnt=1; $cnt<=$parallelLoaders; $cnt++) {%>
	
		/**
		 * Gate<%=$cnt%>
		 * The Gate operator is used to open or close the gate for one by one file processing . 
		 */	
		stream<AddFileName> Gate<%=$cnt%> = Gate(Split<%=$cnt%> ; Control<%=$cnt%> as Control)
		{
			param
				maxUnackedTupleCount : 1u ;
				numTuplesToAck : Control.count; // acknowledge given number of tuples              
   
			config
				placement : partitionColocation("Split") ; // ensure same PE as ThreadedSplit 
		}
 
		/**
		 * LoadOracleFile<%=$cnt%>
		 * Calls composite OracleLoadFile with new fileName.   
		 */	
		stream<rstring result> LoadOracleFile<%=$cnt%> = OracleLoadFile(Gate<%=$cnt%>)
		{
			config
				placement : partitionColocation("LoadOracleFile<%=$cnt%>") ;
		}
		
		 
		/**
		 * Control<%=$cnt%>
		 * Opens the Gate<%=$cnt%> for the file.  
		 */	
		stream<uint32 count, boolean loaded, rstring result> Control<%=$cnt%> as Control = Custom(LoadOracleFile<%=$cnt%>)
		{
			logic 
			state :
				{ 
					mutable uint32 counter = 0 ;
					mutable boolean successfull = false;
					mutable int32 successfulLoaded = 0;
					mutable rstring lastResult = "";
					mutable rstring logInfo = "";
				}
	  
				onTuple LoadOracleFile<%=$cnt%> :
				{
					if(lastResult != result)
					{
						counter ++;
						successfulLoaded = findFirst(result, "SUCCESSFULLY", 0) ;
						if(successfulLoaded == -1)
						{
							successfull = false;
						}
						else
						{
							successfull = true;
						}
						lastResult = result;
						logInfo = result +   "\n                         Loader <%=$cnt%> " + (rstring)counter;
						printStringLn("LoadOracleFile0<%=$cnt%> " + (rstring)counter + " " + (rstring)successfull + " " + result);
						submit({ count = 1u, loaded = successfull , result = logInfo}, Control) ;
					}
					
				}
				// Place on a different PE from Gate and other processing operator
      			config
        			placement : partitionExlocation("Process");
			}
		
		<% } if ($parallelLoaders == 1)
		{ %> 
		stream<uint32 count, boolean loaded, rstring result> CollectResults = Functor(Control1)
		{                                       
		} 
		<% } else {%>
		
		/**
		 * CollectResults
		 * Collects results from all loaders. 
		 */	
		stream<uint32 count, boolean loaded, rstring result> CollectResults = Union (<% my $cnt=0;  for ($cnt=1; $cnt<=$parallelLoaders; $cnt++) {%>
		Control<%=$cnt%><% if ($cnt < $parallelLoaders) { %>;<% }} %>) 
		{                                      
		}
		<% }%>
		
		
		/** 
		 * CalculateMetrics
		 * Calculate the number of succeeded or failed files.
		 */
		stream<rstring result, int64 succeeded, int64 failed> CalculateMetrics= Custom(CollectResults)
		{
			logic
				state :
				{
					mutable int64 failed = 0 ;
					mutable int64 succeeded = 0 ;
					mutable rstring logInfo  = "" ;
				}

				onTuple CollectResults :
				{
					if(loaded)
					{	
						succeeded ++ ;
					}
					else
					{
						failed ++ ; 
					}
					
					logInfo = result 
						+ "\n                         Sum of successfully loaded files : " +(rstring) succeeded 
						+ "\n                         Sum of failed files : " +(rstring) failed;
					submit({ result = logInfo , succeeded = succeeded , failed = failed}, CalculateMetrics) ;					 
				}
		}
			
		/** 
		 * MetricsWriter
		 * write the number of succeeded or failed files. 
		 */
		() as MetricsWriter = MetricsSink(CalculateMetrics)
		{
			logic
				state :
				{
					mutable int64 Failed = 0 ;
					mutable int64 Succeeded = 0 ;
				}

				onTuple CalculateMetrics :
				{
					Succeeded = succeeded;
					Failed = failed; 	 
					printStringLn("Sum of successfully loaded files : " +(rstring) Succeeded +
						"\nSum of failed files : " +(rstring) Failed + "\n" );
					printStringLn("************************************************************************") ;
					
				}
				
			param
				metrics : Succeeded, Failed ;
				names : "Succeeded", "Failed" ;
				descriptions : "Sum of successfully loaded files", "Sum of failed files" ;
				initialValues : 1000l, 1000l ;
		}
		
		/**
		 * LogResult
		 * Writes the result in log file. 
		*/
		() as LogResult = Logger(CalculateMetrics)
		{
		}
		
		
		/**
		 * Result
		 * Send the tuple (boolean loaded) out now.
		 */
		stream<rstring  result> Result = Custom(CollectResults)
		{
			logic
				onTuple CollectResults :
				{
						submit({ result = (rstring)CollectResults.loaded }, Result) ;
				}

		} // End of Result = Custom(CollectResults)

} /** End of composite OracleLoader */ 
